
![](http://www.telerikacademy.com/images/default-source/Homepage/telerik_academy_alpha_hp.png?sfvrsn=0)
# C\# OOP Teamwork Assignment - .NET Alpha Jul'18
-----------------------------------------------------
### CONTENT
# A) Teamwork Assigment and Requirements
# B) Team Workflow 
-----------------------------------------------------
# A) Teamwork Assigment and Requirements

## Project Description

Design and implement an object-oriented application by choice. Here are some suggestions:
- A game:
  - The world can be fantasy, sci-fi, modern, etc
  - You may have one or more heroes, gaining experience, having skills, wearing items, etc
  - You may have one or more players, fighting against a computer or against each other
  - You may have enemies like creatures, machines, warriors, etc
  - You may have items like swords, guns, armor, space-suits, etc
  - You may have skills like double-damage, teleportation, etc
- A line-of-business application:
  - TODO list application, TODOs can have a deadline, priorities, types etc
  - Calendar application, keeping meetings with places and date, having notifications, etc
  - Social network, with different users, different roles, friend list, user information, chat between users, groups of users, etc
  - A chat application, supporting user-to-user chats, channels, group chats, friends-list, starred users, etc
  - Application for Insurance company
  - Informational system for Postal services (sending & receiving mails, packages, etc)
  - Encyclopedia game
  - Geocaching game
  - “Tourist guide” informational system
  - Cooking e-book
  - Personal accounting system
  - Personal medical cart
  - Events scheduling system


## General Requirements
Please define and implement the following object-oriented assets in your project:

- At least **5 interfaces** (with one or more implementations)
- At least **15 classes** (implementing the application logic)
- At least **3 abstract classes** (with inheritors)
- At least **1 custom exception class** (with usage in your code)
- At least **3 levels of depth in inheritance**
- At least **1 polymorphism usage**
- At least **1 structure**
- At least **1 enumeration**
- At least **1 event** (with subscribers)
- At least **1 design pattern** (e.g. Composite, Singleton, Factory, Wrapper, Bridge, Command,  etc.)

You might read about design patterns in Wikipedia, Sourcemaking, DoFactory and others.

## Additional Requirements
- Follow the **best practices for OO design**: use data encapsulation, use exception handling properly, use delegates and events, use inheritance, abstraction and polymorphism properly, follow the principles of strong cohesion and loose coupling
- Obligatory use Git to keep your source code and for team collaboration 
- Provide a class diagram (to visualize all types)

## Optional Requirements
If you have a chance, time and a suitable situation, you might add some of the following to your project:

- Static members (fields, properties, constructor, etc.)
- Constants, generic types, indexers, operators overloading
- Lambda expressions and LINQ
- Implementation of `IEnumerable<T>`, `ICloneable`, `ToString()` override
- Namespaces (if your classes are too many)
- User interface (UI) – console, desktop, web, mobile or as you like it the most

## Non-Required Work
- Completely finished project is not obligatory required. It will not be a big problem if your project is not completely finished or is not working greatly. This team work project is for educational purpose. Its main purpose it to experience object-oriented modeling and OOP in a real-world project and to get some experience in team working and team collaboration with Git.

## Deliverables
- The complete source code.
- Brief documentation of your project in **.md**(markdown). It should provide the following information (in brief):
  - Team name and list of team members (with http://telerikacademy.com usernames)
  - Project purpose – what problem do you solve and how?
  - Class diagram of your types
  - The URL of your Git repository
  - Any other information (optionally)
- Obligatory upload your projects in the Showcase system (http://best.telerikacademy.com/)
- Optionally provide a PowerPoint presentation designed for the project defense

## Public Project Defense
Each team will have to deliver a public defense of its work in front of the trainers and give a short presentation in front of the other students. You will have around 30 minutes for the following:
- Demonstrate the application
- Show the class diagram
- Show the source code in the Git web-based source code browser.
- Show the commits logs to confirm that each team member has contributed.

## Give Feedback about Your Teammates
You will be invited to provide feedback about all your teammates, their attitude to this project, their technical skills, their team working skills, their contribution to the project, etc. The feedback is important part of the project evaluation so **take it seriously and be honest**.

# B)  TEAM 7 WORKFLOW

# Telerik Alpha 2018 Team Project 01 WorkFlow Example

| **Step** | **Task** | **Start Date** | **End Date** |
| --- | --- | --- | --- |
| **Schedule** | **Consider all team members free/ work time to find the best time for work** |   |   |
| **Ideas Gathering** | **Let&#39;s all team members add more ideas** | **19/7** |   |
| **The idea** | **Chose the best idea from the ideas sheet or a new one** | 23/7  |   |
| **1. 1) **Getting Requirements** | **Getting requirements from TA course** | 20/7  |   |
| **1.2) Getting requirements for project** | **Finding requirements for current project** |19/7   |   |
| **1. 2) **Plan** | **Planning development of the project** | 19/7  |   |
| **1. 3) **Design** | **Design the project** |  19/7 |   |
| **1. 4) **Develop** | **Developing the project** |  from 19/7 |   |
| **1. 5) **Release** | **Releasing project as completed IF THERE IS NO TIME LEFT FOR STEP 6)** |   |   |
| **1. 6) **Extend** | **Extend project and do step 5)** |   |   |

# Step 1 Getting Requirements

**Software Requirement Specification (SRS):**

**A textual description of the overall responsibilities and scope of the system.**

**Define the functional requirements of the system.**

**• Identify the boundaries of the system.**

**• Identify the users of the system.**

** • Describe the interactions between the system and the external users.**

** • Establish a common language between the client and the program team for describing the system.**

**• Provide the basis for modeling use cases.**

**NOTE: Some of this are going to be given by TA**

# Step 2 Plan

- **Creating in-dept story line of the app**
- **Creating class diagram (full)**
- **Active discussion about program work flow**
- **Adding all neaded OOP principles from requirements**
- **Discussion of all done so far**
- **Repeat this STEP again**

# Step 03 Design

- **Design all on paper and create Readme file for presentation**
- **Who will going to do what and how ?**

# Step 04 Develop

- **Developing the project**
- **Please Add hire HOW TO DO THIS?**
  - **oo**** On 2-3 days in one place**
  - **oo**** Every member to do special case**
  - **oo**** Or ? ……………**
  - **oo**

# Step 05 Release And Extend

**Creating at first simple app and then extend it to max – based on time left ?**

# Ideas List

# Life Simulator ( second idea - accepted by team )

**IDEA OVERWIEW**

------------- HERE WE MUST DESCRIBE ALL THINGS -----------

**Project Structure**
**DOCUMENTATION**
1. Solution
** ** 
2. LifeSim.CLI - Contain the start point of Console Application Clien.
3. LifeSim_V01_01 - Contains the current under-dev. application.
      - CLI.Module - All functions for console application
          * Contracts
            - IConsoleReader 
            - IConsoleWriter
          * Modules - All functions that are used in CLI
            - ConsoleRead - read line from console
            - ConsoleWriter - write line to console
      - Common - All enums
      - Contracts - All Interfaces that are common for the all project, not for small part of it.
          * IReadable - provides I for readin from file ( this function may be used in the future by the global user )
          * IDisplayable - expose line of text to the user ( this function may be used in the future by the global user )
      - Engine - the main engine of app.
        - Engine.Core - the core part of engine
        - Menu - the menu part that works with Engine
          * Const 
            * MDErrorMessages - all const values for errors displayed by menu
            * MDMessages - menu messages ( not errors )
            * MenuSettings - Contains all menu build in display settings
          * Contracts           
          * Start.Menu - All neaded for providing start menu
            * Logo - folder that stores the logo image
            * MenuLauncher - When it's called it's displays all menu ( NOTE: it must return some valu?)
      - Factories - optional for all factories connected to global parts of project.
      - Models - all global classes that represent part of the app
      - WorkFunctions - stores all common functions that are used in app work
            * FileReader - Implements IReadable - read file from specific path and return List of strings.
            * OutputDisplayer - displays lines from List-string
4. (OPTIONAL)LifeSim_V01_01.Tests - Optionaly, some test on current application.

NOTE: The Contracts and Factories folders (namespaces) must be saved for more "global" purposes. I'give an example-> I'm working on menu, so i will create Contracts folder in my menu folder. Separete all in different folder.
NOTE: ALL THIS IS OPTIONAL, ADD SOME TY
NOTE: Add your changes and new futures to this list.
MAP : - global user - programmer
** ** 

**Конзолна игра** ( first idea but not accepted by team )

Вашата задача е да направите програма, която наподобява стари аркадни игри като [Space Invaders](https://en.wikipedia.org/wiki/Space_Invaders) и [Space Impact](http://nokia.wikia.com/wiki/Space_Impact). Играта ще се играе от конзолния интерфейс, а фигурите в играта ще се чертаят като ASCII символи. Чертането на фигурите ще се случва на кадри, като всеки кадър е матрица със символи, представящи състоянието на играта в текущия момент. Всеки кадър има известна продължителност, преди да се смени със следващия. Като това време зависи от трудността на играта,която ще се избира при пускане на програмата. Вие трябва да прецените колко време ще протича всеки кадър, за всяка от трудностите. Няма ограничение върху продължителността играта. Тя приключва, когато играчът загуби всичките си животи. Играта пази резултат, който се базира на броя убити врагове.

За стила на фигурите в играта се позволява креативна свобода, стига да са изпълнени описаните надолу условия. Ще бъдат дадени и примери за отправна точка.

 Играта има няколко типа обекти, който имат размерност и координати на централната им точка. Те се движат всеки кадър, сменяйки координатите си, но запазват своята размерност.

**Обекти в играта:**

- Играч

 В стила на аркадните игри, формата на играча трябва да наподобява космически кораб. Подбора на формата му и символите, описващи го, са във вашите ръце. Корабът може да се движи в четирите посоки на екрана и може да стреля в една. В началото на играта, играчът е в средата (по вертикала) на лявата част на прозореца, и стреля надясно. Корабът има три живота в началото на играта и му се премахва по един живот за всеки път, в който е уцелен или се е блъснал във враг.

- Врагове

 Враговете могат да са повече от един във всеки момент. Те се създават в дясната част на екрана, като вертикалната им позиция трябва да е произволна. Времето, за което се създава нов враг, трябва да е произволно. Отново, формата и символите, съставящи враг, се оставят на избора на програмиста. Стрелбата им е насочена наляво, към играча, и времето до следващият им изстрел е произволен брой кадри. Тяхното движение е праволинейно, към лявата част на екрана, и е по-бавно от това на играча.

- Снаряд

 Снарядът се произвежда от играчът и от враговете. Той се движи праволинейно. Снаряд, изстрелян от враг, може да уцели само играча, не и друг враг. Когато играча бъде уцелен, му се взема живот, а когато враг бива уцелен - той се премахва от играта. Снарядите се движат най-бързо в играта и се визуализират само с един символ (например тире), движещо се хоризонтално по координатната мрежа.

- Координатна мрежа

 Това е матрица и единствено нейните елементи ще се визуализират. Тя ще съдържа всички символи, изобразяващи различните обекти, и ще ги извежда на екрана във всеки кадър.



**Описание на кадър:**

 За всеки кадър трябва да се изпълнят няколко операции в този ред или в ред, в който операциите не си пречат.

1. Вход от потребителя - за стрелба или посока на движение (Виж HINTS)
2. Придвижване на играча в координатната мрежа
3. Произвеждане на изстрел от играча (ако е натиснал клавиш за това) и от враговете (ако времето до следващия изстрел е изтекло)
4. Засичане и обработване на колизии между снаряд и играч, снаряд и враг, играч и враг
5. Придвижване на снарядите в координатната мрежа
6. Придвижване на врагове в координатната мрежа
7. Извеждане на екрана на координатната мрежа създадена в текущия кадър

**Добавка за практикума:**

Да се направи така, че играта да може да запазва състоянието си, когато се натисне клавиша &#39;S&#39;. Също така, при пускане на програмата да се дава опция за продължаване на предишна запазена игра. Сами преценете какъв формат да използвате при сериализацията на обектите.

**HINTS:**

- --Key press without blocking in Windows:

[http://www.cplusplus.com/forum/windows/6632/](http://www.cplusplus.com/forum/windows/6632/)

[https://stackoverflow.com/questions/17770753/getkeystate-vs-getasynckeystate-vs-getch](https://stackoverflow.com/questions/17770753/getkeystate-vs-getasynckeystate-vs-getch)

[https://msdn.microsoft.com/en-us/library/windows/desktop/ms646293(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms646293(v=vs.85).aspx)

- --Key press without blocking in Linux:

[https://stackoverflow.com/questions/20349585/c-library-function-to-check-the-keypress-from-keyboard-in-linux](https://stackoverflow.com/questions/20349585/c-library-function-to-check-the-keypress-from-keyboard-in-linux)

[https://www.linuxquestions.org/questions/programming-9/game-programming-non-blocking-key-input-740422/](https://www.linuxquestions.org/questions/programming-9/game-programming-non-blocking-key-input-740422/)

[https://www.quora.com/How-can-I-take-arrow-keys-as-input-in-C](https://www.quora.com/How-can-I-take-arrow-keys-as-input-in-C)

**Бонус:**

**       ** Всяка допълнителна функционалност, която допринася за потребителското изживяване, носи бонус точки. Пример за такива функционалности са:

- --По-сложно поведение на враговете
- --Различни видове врагове
- --Boss fights, след някакво време в играта, или когато се достигне определен резултат
- --Бонус животи, които играчът може да събира, минавайки през тях. Те се появяват на екрана, през определен интервал
- --Подобряване на оръжието на космическия кораб
- --Различна траектория на снарядите
- --Добавяне на &quot;теренен пейзаж&quot; - отгоре или отдолу игровото поле е ограничено от променящ се пейзаж - прелита се над сгради, скали и други препятствия.

[**Ето как изглеждаше играта на стара nokia**](https://www.youtube.com/watch?v=22k8dshnAv0&amp;t=16s)

**Примери за обекти:**

Примерна форма за кораб : IMG/img01

Примерна форма за враг, който изстрелва снаряд : IMG/img01

Примерна игрова сцена : IMG/img01